# -*- coding: utf-8 -*-
"""Shweta Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KXK0RNWUHhyT6d0bqZyATyjhOs4omnt4
"""

import os
import requests
import wfdb

# Directory to save downloaded files
download_dir = "mitdb"
os.makedirs(download_dir, exist_ok=True)

# GitHub repo details
user = "rajeshkumar-niet"
repo = "ECG"
folder = "Data"
api_url = f"https://api.github.com/repos/{user}/{repo}/contents/{folder}"

# Get file list from GitHub API
response = requests.get(api_url)
if response.status_code == 200:
    files = response.json()
    print(f"üìÑ Found {len(files)} files in '{folder}' on GitHub.")
else:
    raise Exception(f"‚ùå Failed to fetch file list (status code: {response.status_code})")

# Download each file
for file in files:
    filename = file['name']
    download_url = file['download_url']
    local_path = os.path.join(download_dir, filename)

    if not os.path.exists(local_path):
        print(f"‚¨áÔ∏è Downloading {filename} ...")
        r = requests.get(download_url)
        if r.status_code == 200:
            with open(local_path, 'wb') as f:
                f.write(r.content)
        else:
            print(f"‚ùå Failed to download {filename} (HTTP {r.status_code})")
    else:
        print(f"‚úÖ Already exists: {filename}")

# Load a specific ECG record
record_name = "mitdb/118e00"
record = wfdb.rdrecord(record_name)

# Extract ECG signal
ecg_clean = record.p_signal[:, 0]
fs = record.fs

print(f"\n‚úÖ Clean ECG loaded from {record_name} | Shape: {ecg_clean.shape} | Sampling Rate: {fs} Hz")

import os

# Use the record name available in your directory
record_name = '118e00'
mitdb_path = '/content/mitdb'
required_files = [f"{record_name}.dat", f"{record_name}.hea"]

# Check existence and size
all_exist = True
for file in required_files:
    file_path = os.path.join(mitdb_path, file)
    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        print(f"‚úÖ {file} found | Size: {os.path.getsize(file_path)} bytes")
    else:
        print(f"‚ùå {file} not found or is empty!")
        all_exist = False

if all_exist:
    print("\n‚úÖ All required files are present.")
else:
    print("\n‚ùå Some files are missing or empty.")

!pip install wfdb

import wfdb

# Path to your uploaded MITDB record
record_path = 'sample_data/mitdb/118e00'

# Load the record
record = wfdb.rdrecord(record_path)

# Extract the ECG signal (assuming first channel is ECG)
ecg_clean = record.p_signal[:, 0]
fs = record.fs  # Sampling frequency

print(f"‚úÖ Clean ECG loaded | Shape: {ecg_clean.shape} | Sampling Rate: {fs} Hz")

import wfdb
import numpy as np
import os

# Define base path to NSTDB signals
nstdb_path = 'sample_data/mitdb/'

# Function to read a full signal from NSTDB
def read_nstdb_signal(signal_name, channel=0):
    record = wfdb.rdrecord(os.path.join(nstdb_path, signal_name))
    return record.p_signal[:, channel]

# Load noise signals
baseline_wander = read_nstdb_signal('bw')     # Baseline Wander
muscle_artifact = read_nstdb_signal('ma')     # Muscle Artifact
electrode_motion = read_nstdb_signal('em')    # Electrode Motion

# Save as .npy files
np.save('baseline_wander.npy', baseline_wander)
np.save('muscle_artifact.npy', muscle_artifact)
np.save('electrode_motion.npy', electrode_motion)

print("‚úÖ Noise signals saved as .npy files.")

# Function to add noise to ECG with optional scaling
def add_noise(ecg, noise, snr_db):
    # Normalize both signals
    ecg_power = np.mean(ecg**2)
    noise_power = np.mean(noise**2)

    # Compute scaling factor for noise
    snr_linear = 10 ** (snr_db / 10)
    scaling_factor = np.sqrt(ecg_power / (snr_linear * noise_power))

    # Resize noise to match ECG length
    if len(noise) < len(ecg):
        noise = np.tile(noise, int(np.ceil(len(ecg)/len(noise))))[:len(ecg)]
    else:
        noise = noise[:len(ecg)]

    noisy_signal = ecg + scaling_factor * noise
    return noisy_signal

# Add different types of noise
snr_level = 5  # in dB (you can tweak this)

noisy_ecg_bw = add_noise(ecg_clean, baseline_wander, snr_level)
noisy_ecg_ma = add_noise(ecg_clean, muscle_artifact, snr_level)
noisy_ecg_em = add_noise(ecg_clean, electrode_motion, snr_level)

print("‚úÖ Noise added to ECG signal with SNR =", snr_level, "dB")

import matplotlib.pyplot as plt

# Define a segment for visualization (first 5 seconds)
fs = 360
start = 0
end = 5 * fs
time = np.arange(start, end) / fs

plt.figure(figsize=(15, 10))

# Clean ECG
plt.subplot(4, 1, 1)
plt.plot(time, ecg_clean[start:end], label='Clean ECG', color='black')
plt.title('Clean ECG')
plt.ylabel('Amplitude')
plt.grid(True)

# ECG with Baseline Wander
plt.subplot(4, 1, 2)
plt.plot(time, noisy_ecg_bw[start:end], label='ECG + Baseline Wander', color='orange')
plt.title('ECG with Baseline Wander')
plt.ylabel('Amplitude')
plt.grid(True)

# ECG with Muscle Artifact
plt.subplot(4, 1, 3)
plt.plot(time, noisy_ecg_ma[start:end], label='ECG + Muscle Artifact', color='green')
plt.title('ECG with Muscle Artifact')
plt.ylabel('Amplitude')
plt.grid(True)

# ECG with Electrode Motion
plt.subplot(4, 1, 4)
plt.plot(time, noisy_ecg_em[start:end], label='ECG + Electrode Motion', color='red')
plt.title('ECG with Electrode Motion')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.grid(True)

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt

def butter_highpass(cutoff, fs, order=5):
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='high', analog=False)
    return b, a

def butter_lowpass(cutoff, fs, order=5):
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def butter_bandpass(lowcut, highcut, fs, order=5):
    nyquist = 0.5 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band', analog=False)
    return b, a

def apply_highpass_filter(ecg_signal, fs):
    cutoff = 0.5  # Cutoff frequency for Baseline Wander removal
    b, a = butter_highpass(cutoff, fs)
    filtered_signal = filtfilt(b, a, ecg_signal)
    return filtered_signal

def apply_lowpass_filter(ecg_signal, fs):
    cutoff = 20  # Cutoff frequency for Muscle Artifact removal
    b, a = butter_lowpass(cutoff, fs)
    filtered_signal = filtfilt(b, a, ecg_signal)
    return filtered_signal

def apply_bandpass_filter(ecg_signal, fs):
    lowcut = 0.5  # Low cut frequency for Electrode Motion removal
    highcut = 50  # High cut frequency for Electrode Motion removal
    b, a = butter_bandpass(lowcut, highcut, fs)
    filtered_signal = filtfilt(b, a, ecg_signal)
    return filtered_signal

# Define a segment for visualization (first 5 seconds)
start = 0
end = 5 * fs
time = np.arange(start, end) / fs

# Apply the high-pass filter (Baseline Wander removal)
filtered_bw = apply_highpass_filter(noisy_ecg_bw, fs)

plt.figure(figsize=(15, 10))

# Clean ECG
plt.subplot(3, 1, 1)
plt.plot(time, ecg_clean[start:end], label='Clean ECG', color='black')
plt.title('Clean ECG')
plt.ylabel('Amplitude')
plt.grid(True)

# ECG with Baseline Wander (Before filtering)
plt.subplot(3, 1, 2)
plt.plot(time, noisy_ecg_bw[start:end], label='ECG + Baseline Wander', color='orange')
plt.title('ECG with Baseline Wander')
plt.ylabel('Amplitude')
plt.grid(True)

# ECG with Baseline Wander (After filtering)
plt.subplot(3, 1, 3)
plt.plot(time, filtered_bw[start:end], label='Filtered ECG (Baseline Wander)', color='blue')
plt.title('ECG with Baseline Wander (Filtered)')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.grid(True)

plt.tight_layout()
plt.show()

import numpy as np

# Load clean ECG (you already loaded it earlier ‚Äî make sure variable still exists or reload if needed)
# ecg_clean = ... (already loaded previously)

# Load noise signals from .npy files
baseline_wander = np.load('baseline_wander.npy')
muscle_artifact = np.load('muscle_artifact.npy')
electrode_motion = np.load('electrode_motion.npy')

# Truncate or pad noise signals to match length of clean ECG
def match_length(signal, target_length):
    if len(signal) > target_length:
        return signal[:target_length]
    else:
        return np.pad(signal, (0, target_length - len(signal)), 'constant')

# Match lengths
bw = match_length(baseline_wander, len(ecg_clean))
ma = match_length(muscle_artifact, len(ecg_clean))
em = match_length(electrode_motion, len(ecg_clean))

# Create noisy signals with different types of noise
ecg_bw = ecg_clean + bw
ecg_ma = ecg_clean + ma
ecg_em = ecg_clean + em

# Combine all noisy signals for training
X_noisy = np.stack([ecg_bw, ecg_ma, ecg_em])  # Shape: (3, N)
Y_clean = np.stack([ecg_clean] * 3)           # Shape: (3, N)

# Normalize between 0 and 1 (optional but recommended for DL models)
def normalize(signal):
    return (signal - np.min(signal)) / (np.max(signal) - np.min(signal))

X_noisy_norm = np.array([normalize(sig) for sig in X_noisy])
Y_clean_norm = np.array([normalize(sig) for sig in Y_clean])

print("‚úÖ Training pairs prepared.")
print("Noisy signals shape:", X_noisy_norm.shape)
print("Clean signals shape:", Y_clean_norm.shape)

import tensorflow as tf
from tensorflow.keras import layers, models

# Input shape
input_shape = (650000, 1)  # One channel

# Build the model
def build_ecg_denoising_model():
    input_layer = layers.Input(shape=input_shape)

    # Encoder
    x = layers.Conv1D(16, kernel_size=7, strides=2, padding='same', activation='relu')(input_layer)
    x = layers.MaxPooling1D(pool_size=2, padding='same')(x)
    x = layers.Conv1D(32, kernel_size=5, strides=2, padding='same', activation='relu')(x)
    x = layers.MaxPooling1D(pool_size=2, padding='same')(x)

    # Bottleneck
    x = layers.Conv1D(64, kernel_size=3, strides=2, padding='same', activation='relu')(x)

    # Decoder
    x = layers.UpSampling1D(size=2)(x)
    x = layers.Conv1D(32, kernel_size=5, padding='same', activation='relu')(x)
    x = layers.UpSampling1D(size=2)(x)
    x = layers.Conv1D(16, kernel_size=7, padding='same', activation='relu')(x)
    x = layers.UpSampling1D(size=2)(x)

    # Output layer
    output_layer = layers.Conv1D(1, kernel_size=1, activation='linear', padding='same')(x)

    model = models.Model(inputs=input_layer, outputs=output_layer)
    return model

# Instantiate and compile
model = build_ecg_denoising_model()
model.compile(optimizer='adam', loss='mse')

# Summary
model.summary()

import numpy as np

# Load noise signals
baseline_wander = np.load('baseline_wander.npy')
muscle_artifact = np.load('muscle_artifact.npy')
electrode_motion = np.load('electrode_motion.npy')

# Function to add noise to clean ECG with a given SNR (in dB)
def add_noise(ecg_clean, noise_signal, snr_db=5):
    noise_signal = noise_signal[:len(ecg_clean)]
    signal_power = np.mean(ecg_clean**2)
    noise_power = np.mean(noise_signal**2)
    k = np.sqrt(signal_power / (10**(snr_db / 10) * noise_power))
    return ecg_clean + k * noise_signal

# Re-create noisy ECGs
ecg_noisy_bw = add_noise(ecg_clean, baseline_wander, snr_db=5)
ecg_noisy_ma = add_noise(ecg_clean, muscle_artifact, snr_db=5)
ecg_noisy_em = add_noise(ecg_clean, electrode_motion, snr_db=5)

# Stack and save
noisy_signals = np.stack([ecg_noisy_bw, ecg_noisy_ma, ecg_noisy_em])
clean_signals = np.stack([ecg_clean, ecg_clean, ecg_clean])

np.save("noisy_signals.npy", noisy_signals)
np.save("clean_signals.npy", clean_signals)

print("‚úÖ Noisy and clean signals prepared and saved.")

import numpy as np

# Assuming ecg_clean is your original clean ECG
# and ecg_noisy_bw, ecg_noisy_ma, ecg_noisy_em are the noisy signals

# Stack noisy signals
noisy_signals = np.stack([ecg_noisy_bw, ecg_noisy_ma, ecg_noisy_em])

# Replicate the clean ECG 3 times to match shape
clean_signals = np.stack([ecg_clean, ecg_clean, ecg_clean])

# Save to .npy files
np.save("noisy_signals.npy", noisy_signals)
np.save("clean_signals.npy", clean_signals)

print("‚úÖ Noisy and clean signals saved for training.")

from tensorflow.keras.layers import Input, Conv1D, MaxPooling1D, UpSampling1D
from tensorflow.keras.models import Model

input_layer = Input(shape=(650000, 1))

# Encoder
x = Conv1D(16, kernel_size=3, padding='same', activation='relu')(input_layer)
x = MaxPooling1D(pool_size=2, padding='same')(x)   # 325000
x = Conv1D(32, kernel_size=3, padding='same', activation='relu')(x)
x = MaxPooling1D(pool_size=2, padding='same')(x)   # 162500
x = Conv1D(64, kernel_size=3, padding='same', activation='relu')(x)
x = MaxPooling1D(pool_size=2, padding='same')(x)   # 81250

# Decoder
x = UpSampling1D(size=2)(x)                        # 162500
x = Conv1D(64, kernel_size=3, padding='same', activation='relu')(x)
x = UpSampling1D(size=2)(x)                        # 325000
x = Conv1D(32, kernel_size=3, padding='same', activation='relu')(x)
x = UpSampling1D(size=2)(x)                        # 650000
decoded = Conv1D(1, kernel_size=3, padding='same', activation='linear')(x)

model = Model(input_layer, decoded)
model.compile(optimizer='adam', loss='mse')

model.summary()

# Load training data
noisy = np.load("noisy_signals.npy")     # Shape: (3, 650000)
clean = np.load("clean_signals.npy")     # Shape: (3, 650000)

# Reshape for model: (samples, timesteps, channels)
X = noisy[..., np.newaxis]
y = clean[..., np.newaxis]

# Split into training and validation
from sklearn.model_selection import train_test_split
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.33, random_state=42)

# Train the model
history = model.fit(
    X_train, y_train,
    validation_data=(X_val, y_val),
    epochs=20,
    batch_size=1,
    verbose=1
)

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 4))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss Over Epochs')
plt.xlabel('Epoch')
plt.ylabel('MSE Loss')
plt.legend()
plt.grid(True)
plt.show()

# Predict on validation data
predicted = model.predict(X_val)

# Plot original, noisy, and denoised ECG
i = 0  # Choose a sample index from validation set

plt.figure(figsize=(15, 6))

plt.subplot(3, 1, 1)
plt.plot(y_val[i], color='green')
plt.title("Clean ECG (Ground Truth)")

plt.subplot(3, 1, 2)
plt.plot(X_val[i], color='red')
plt.title("Noisy ECG (Input)")

plt.subplot(3, 1, 3)
plt.plot(predicted[i], color='blue')
plt.title("Denoised ECG (Model Output)")

plt.tight_layout()
plt.show()

model.save("ecg_denoising_autoencoder.h5")
print("Model saved as ecg_denoising_autoencoder.h5 ‚úÖ")

def compute_snr(clean, denoised):
    noise = clean - denoised
    snr = 10 * np.log10(np.sum(clean ** 2) / np.sum(noise ** 2))
    return snr

snr_value = compute_snr(y_val.flatten(), predicted.flatten())
print(f"Signal-to-Noise Ratio (SNR): {snr_value:.2f} dB")

model.save("ecg_denoising_autoencoder.keras")
print("Model saved in recommended Keras format ‚úÖ")